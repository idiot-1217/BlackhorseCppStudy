/*
***对象特性***
*构造函数：对象初始化；类名(){}
1.构造函数，没有返回值也不写void
2.函数名称与类名相同
3.构造函数可以有参数，因此可以发生重载
4.程序在调用对象时候会自动调用构造，无须手动调用,而且只会调用一次

*构造函数的分类：
1.按照参数分类为有参构造和无参构造，无参构造亦称为默认构造
2.按照类型分类为普通构造和拷贝构造
class Person {
public:
	Person() {
	}
	Person(int a) {
	}
	Person(const Person& p) {
	}
}

*构造函数的调用
1。括号法 Person p1(10);调用无参构造函数时不用加括号，否则是函数声明
2。显式法 Person p2 = Person(10); Person p3 = Person(p2);前面是普通后面是拷贝。Person(10)为匿名对象
匿名对象当前行运行完即刻释放。
3。隐式转换法 Person p4 = 10; Person p5 = p4;不能利用拷贝构造函数初始化匿名对象，编译器认为是对象声
明Person p5(p4)

*拷贝构造函数的调用时机
1. 使用已创建的对象初始化一个新对象
void test01() {
	Person p1;
	Person p2(p1);
}
2. 值传递的方式给函数参数传值
void do(Person p) {
}
void test02() {
	Person p3;
	do(p3);
}
3. 值方式返回局部对象
void do2() {
	Person p4;
	return p4;
} //返回对象的副本
void test03() {
	Person p5 = do2();
}

*构造函数的调用规则
默认情况下，创建一个类，C++至少提供三个函数，即默认构造函数、默认析构函数、拷贝构造函数
如果用户自定义了有参构造函数，那么C++不再提供默认的无参构造函数，但依然提供拷贝构造函数。
如果用户给定了拷贝构造函数，那么C++不再提供其他的构造函数。

*深拷贝与浅拷贝
浅拷贝：简单的拷贝赋值操作。
深拷贝：在堆区重新开辟空间，用于拷贝。
堆区开辟的数据通过析构函数释放
if (m_h != NULL) {
	delete m_h;
	m_h = NULL;
}
浅拷贝带来的问题是 堆区的数据重复释放。解决方法为深拷贝，用户另写拷贝构造函数，在堆区重新
开辟一块空间。

*初始化列表
Person() :m_a(10),m_b(20)
{
}
或者
Person(int a, int b):m_a(a), m_b(b)
{
}



*析构函数：对象清理；~类名(){}
1.析构函数，没有返回值也不写void
2.函数名称与类名相同,在名称前加上符号 ~
3.析构函数不可以有参数，因此不可以发生重载
4.程序在对象销毁前会自动调用析构，无须手动调用,而且只会调用一次

编译器提供的构造与析构为空实现


*/